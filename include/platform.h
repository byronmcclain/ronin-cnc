/*
 * Red Alert Platform Layer
 * Auto-generated by cbindgen - DO NOT EDIT
 *
 * This header provides the C interface to the Rust platform library.
 */


#ifndef REDALERT_PLATFORM_H
#define REDALERT_PLATFORM_H

/* Generated with cbindgen:0.26.0 */

/* Warning: this file is auto-generated by cbindgen. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Platform version
 */
#define PLATFORM_VERSION 1

/**
 * Key codes (matching Windows VK_* values for compatibility)
 */
typedef enum KeyCode {
  KEY_CODE_NONE = 0,
  KEY_CODE_BACKSPACE = 8,
  KEY_CODE_TAB = 9,
  KEY_CODE_RETURN = 13,
  KEY_CODE_SHIFT = 16,
  KEY_CODE_CONTROL = 17,
  KEY_CODE_ALT = 18,
  KEY_CODE_PAUSE = 19,
  KEY_CODE_CAPS_LOCK = 20,
  KEY_CODE_ESCAPE = 27,
  KEY_CODE_SPACE = 32,
  KEY_CODE_PAGE_UP = 33,
  KEY_CODE_PAGE_DOWN = 34,
  KEY_CODE_END = 35,
  KEY_CODE_HOME = 36,
  KEY_CODE_LEFT = 37,
  KEY_CODE_UP = 38,
  KEY_CODE_RIGHT = 39,
  KEY_CODE_DOWN = 40,
  KEY_CODE_INSERT = 45,
  KEY_CODE_DELETE = 46,
  KEY_CODE_F1 = 112,
  KEY_CODE_F2 = 113,
  KEY_CODE_F3 = 114,
  KEY_CODE_F4 = 115,
  KEY_CODE_F5 = 116,
  KEY_CODE_F6 = 117,
  KEY_CODE_F7 = 118,
  KEY_CODE_F8 = 119,
  KEY_CODE_F9 = 120,
  KEY_CODE_F10 = 121,
  KEY_CODE_F11 = 122,
  KEY_CODE_F12 = 123,
  KEY_CODE_NUM_LOCK = 144,
  KEY_CODE_SCROLL_LOCK = 145,
} KeyCode;

/**
 * Log level for Platform_Log
 */
typedef enum LogLevel {
  LOG_LEVEL_DEBUG = 0,
  LOG_LEVEL_INFO = 1,
  LOG_LEVEL_WARN = 2,
  LOG_LEVEL_ERROR = 3,
} LogLevel;

/**
 * Mouse button
 */
typedef enum MouseButton {
  MOUSE_BUTTON_LEFT = 0,
  MOUSE_BUTTON_RIGHT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
} MouseButton;

/**
 * Result type for platform operations (FFI-compatible)
 */
typedef enum PlatformResult {
  PLATFORM_RESULT_SUCCESS = 0,
  PLATFORM_RESULT_ALREADY_INITIALIZED = 1,
  PLATFORM_RESULT_NOT_INITIALIZED = 2,
  PLATFORM_RESULT_INIT_FAILED = 3,
} PlatformResult;

/**
 * Display mode configuration
 */
typedef struct DisplayMode {
  int32_t width;
  int32_t height;
  int32_t bits_per_pixel;
} DisplayMode;

/**
 * RGB palette entry (matches game format)
 */
typedef struct PaletteEntry {
  uint8_t r;
  uint8_t g;
  uint8_t b;
} PaletteEntry;

/**
 * Opaque surface handle for C
 */
typedef struct PlatformSurface {
  uint8_t _private[0];
} PlatformSurface;

/**
 * Timer handle
 */
typedef int32_t TimerHandle;

/**
 * C timer callback type
 */
typedef void (*CTimerCallback)(void*);

#define INVALID_TIMER_HANDLE -1

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the platform layer
 */
enum PlatformResult Platform_Init(void);

/**
 * Shutdown the platform layer
 */
enum PlatformResult Platform_Shutdown(void);

/**
 * Check if platform is initialized
 */
bool Platform_IsInitialized(void);

/**
 * Get platform version
 */
int32_t Platform_GetVersion(void);

/**
 * Get the last error message into a buffer
 * Returns number of bytes written, or -1 on error
 * Buffer will be null-terminated if there's space
 */
int32_t Platform_GetLastError(int8_t *buffer, int32_t buffer_size);

/**
 * Get error as static string pointer (valid until next error)
 * Returns null if no error
 */
const char *Platform_GetErrorString(void);

/**
 * Set an error message from C string
 */
void Platform_SetError(const char *msg);

/**
 * Clear the last error
 */
void Platform_ClearError(void);

/**
 * Log a message at the specified level
 */
void Platform_Log(enum LogLevel level, const char *msg);

/**
 * Log a formatted debug message
 */
void Platform_LogDebug(const char *msg);

/**
 * Log a formatted info message
 */
void Platform_LogInfo(const char *msg);

/**
 * Log a formatted warning message
 */
void Platform_LogWarn(const char *msg);

/**
 * Log a formatted error message
 */
void Platform_LogError(const char *msg);

/**
 * Initialize graphics subsystem
 */
int32_t Platform_Graphics_Init(void);

/**
 * Shutdown graphics subsystem
 */
void Platform_Graphics_Shutdown(void);

/**
 * Check if graphics is initialized
 */
bool Platform_Graphics_IsInitialized(void);

/**
 * Clear screen with color (for testing)
 */
void Platform_Graphics_Clear(uint8_t r, uint8_t g, uint8_t b);

/**
 * Present the frame
 */
void Platform_Graphics_Present(void);

/**
 * Get display mode
 */
void Platform_Graphics_GetMode(struct DisplayMode *mode);

/**
 * Get back buffer for direct pixel access
 * Returns pointer to 8-bit indexed pixel buffer
 */
int32_t Platform_Graphics_GetBackBuffer(uint8_t **pixels,
                                        int32_t *width,
                                        int32_t *height,
                                        int32_t *pitch);

/**
 * Clear back buffer with color index
 */
void Platform_Graphics_ClearBackBuffer(uint8_t color);

/**
 * Set palette entries
 */
void Platform_Graphics_SetPalette(const struct PaletteEntry *entries, int32_t start, int32_t count);

/**
 * Get palette entries
 */
void Platform_Graphics_GetPalette(struct PaletteEntry *entries, int32_t start, int32_t count);

/**
 * Set single palette entry
 */
void Platform_Graphics_SetPaletteEntry(uint8_t index, uint8_t r, uint8_t g, uint8_t b);

/**
 * Fade palette (0.0 = black, 1.0 = full)
 */
void Platform_Graphics_FadePalette(float factor);

/**
 * Restore palette from fade
 */
void Platform_Graphics_RestorePalette(void);

/**
 * Flip back buffer to screen (full render pipeline)
 */
int32_t Platform_Graphics_Flip(void);

/**
 * Wait for vertical sync (no-op, handled by SDL)
 */
void Platform_Graphics_WaitVSync(void);

/**
 * Draw test pattern to back buffer (for testing)
 */
void Platform_Graphics_DrawTestPattern(void);

/**
 * Get free video memory (returns large value for compatibility)
 */
uint32_t Platform_Graphics_GetFreeVideoMemory(void);

/**
 * Check if hardware accelerated
 */
bool Platform_Graphics_IsHardwareAccelerated(void);

/**
 * Poll events and return true if quit was requested (window close or Escape key)
 */
bool Platform_PollEvents(void);

/**
 * Get tick count in milliseconds since SDL init
 */
uint32_t Platform_GetTicks(void);

/**
 * Delay for specified milliseconds
 */
void Platform_Delay(uint32_t ms);

/**
 * Create a new surface
 */
struct PlatformSurface *Platform_Surface_Create(int32_t width, int32_t height, int32_t bpp);

/**
 * Destroy a surface
 */
void Platform_Surface_Destroy(struct PlatformSurface *surface);

/**
 * Get surface dimensions
 */
void Platform_Surface_GetSize(const struct PlatformSurface *surface,
                              int32_t *width,
                              int32_t *height);

/**
 * Lock surface for direct pixel access
 */
int32_t Platform_Surface_Lock(struct PlatformSurface *surface, void **pixels, int32_t *pitch);

/**
 * Unlock surface
 */
void Platform_Surface_Unlock(struct PlatformSurface *surface);

/**
 * Blit surface to another
 */
int32_t Platform_Surface_Blit(struct PlatformSurface *dest,
                              int32_t dx,
                              int32_t dy,
                              const struct PlatformSurface *src,
                              int32_t sx,
                              int32_t sy,
                              int32_t sw,
                              int32_t sh);

/**
 * Blit with transparency (skip color 0)
 */
int32_t Platform_Surface_BlitTransparent(struct PlatformSurface *dest,
                                         int32_t dx,
                                         int32_t dy,
                                         const struct PlatformSurface *src,
                                         int32_t sx,
                                         int32_t sy,
                                         int32_t sw,
                                         int32_t sh);

/**
 * Fill rectangle
 */
void Platform_Surface_Fill(struct PlatformSurface *surface,
                           int32_t x,
                           int32_t y,
                           int32_t w,
                           int32_t h,
                           uint8_t color);

/**
 * Clear entire surface
 */
void Platform_Surface_Clear(struct PlatformSurface *surface, uint8_t color);

/**
 * Initialize input subsystem
 */
int32_t Platform_Input_Init(void);

/**
 * Shutdown input subsystem
 */
void Platform_Input_Shutdown(void);

/**
 * Update input state (call at start of each frame)
 */
void Platform_Input_Update(void);

/**
 * Check if quit was requested
 */
bool Platform_Input_ShouldQuit(void);

/**
 * Check if key is currently pressed
 */
bool Platform_Key_IsPressed(enum KeyCode key);

/**
 * Check if key was just pressed this frame
 */
bool Platform_Key_WasPressed(enum KeyCode key);

/**
 * Check if key was just released this frame
 */
bool Platform_Key_WasReleased(enum KeyCode key);

/**
 * Get next key event from queue (returns false if empty)
 */
bool Platform_Key_GetNext(enum KeyCode *key, bool *released);

/**
 * Clear key event queue
 */
void Platform_Key_Clear(void);

/**
 * Check if Shift is held
 */
bool Platform_Key_ShiftDown(void);

/**
 * Check if Ctrl is held
 */
bool Platform_Key_CtrlDown(void);

/**
 * Check if Alt is held
 */
bool Platform_Key_AltDown(void);

/**
 * Get mouse position
 */
void Platform_Mouse_GetPosition(int32_t *x, int32_t *y);

/**
 * Get mouse X position
 */
int32_t Platform_Mouse_GetX(void);

/**
 * Get mouse Y position
 */
int32_t Platform_Mouse_GetY(void);

/**
 * Check if mouse button is pressed
 */
bool Platform_Mouse_IsPressed(enum MouseButton button);

/**
 * Check if mouse button was clicked this frame
 */
bool Platform_Mouse_WasClicked(enum MouseButton button);

/**
 * Check if mouse button was double-clicked this frame
 */
bool Platform_Mouse_WasDoubleClicked(enum MouseButton button);

/**
 * Get mouse wheel delta
 */
int32_t Platform_Mouse_GetWheelDelta(void);

/**
 * Show mouse cursor
 */
void Platform_Mouse_Show(void);

/**
 * Hide mouse cursor
 */
void Platform_Mouse_Hide(void);

/**
 * Get milliseconds since platform init
 */
uint32_t Platform_Timer_GetTicks(void);

/**
 * Sleep for milliseconds
 */
void Platform_Timer_Delay(uint32_t milliseconds);

/**
 * Get high-resolution performance counter
 */
uint64_t Platform_Timer_GetPerformanceCounter(void);

/**
 * Get performance counter frequency
 */
uint64_t Platform_Timer_GetPerformanceFrequency(void);

/**
 * Get time in seconds (floating point)
 */
double Platform_Timer_GetTime(void);

/**
 * Create a periodic timer
 * Note: The callback will be called from a separate thread!
 */
TimerHandle Platform_Timer_Create(uint32_t interval_ms, CTimerCallback callback, void *userdata);

/**
 * Destroy a periodic timer
 */
void Platform_Timer_Destroy(TimerHandle handle);

/**
 * Get invalid timer handle constant
 */
TimerHandle Platform_Timer_InvalidHandle(void);

/**
 * Start frame timing
 */
void Platform_Frame_Begin(void);

/**
 * End frame timing (sleeps to maintain target FPS)
 */
void Platform_Frame_End(void);

/**
 * Set target FPS
 */
void Platform_Frame_SetTargetFPS(uint32_t fps);

/**
 * Get last frame time in seconds
 */
double Platform_Frame_GetTime(void);

/**
 * Get current FPS (rolling average)
 */
double Platform_Frame_GetFPS(void);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* REDALERT_PLATFORM_H */
