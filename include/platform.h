/*
 * Red Alert Platform Layer
 * Auto-generated by cbindgen - DO NOT EDIT
 *
 * This header provides the C interface to the Rust platform library.
 */


#ifndef REDALERT_PLATFORM_H
#define REDALERT_PLATFORM_H

/* Generated with cbindgen:0.26.0 */

/* Warning: this file is auto-generated by cbindgen. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Platform version
 */
#define PLATFORM_VERSION 1

/**
 * Frame data is XOR'd with reference frame
 */
#define XOR_DELTA 1

/**
 * Frame data is LCW compressed
 */
#define LCW_COMPRESSED 2

/**
 * Default shadow intensity (50% darkness)
 */
#define DEFAULT_SHADOW_INTENSITY 0.5

/**
 * Maximum key length in bytes
 */
#define BlowfishEngine_MAX_KEY_LENGTH 56

/**
 * Block size in bytes
 */
#define BlowfishEngine_BLOCK_SIZE 8

/**
 * RSA block sizes for Westwood's key
 */
#define RSA_PLAIN_BLOCK_SIZE 39

#define RSA_CRYPT_BLOCK_SIZE 40

/**
 * Magic number for packet validation
 * Original: 0xDABD for serial, various for network
 */
#define PACKET_MAGIC 49374

/**
 * Initial CRC value for streaming calculation
 */
#define CRC_INIT 4294967295

/**
 * File open mode
 */
typedef enum FileMode {
  FILE_MODE_READ = 1,
  FILE_MODE_WRITE = 2,
  FILE_MODE_READ_WRITE = 3,
  FILE_MODE_APPEND = 4,
} FileMode;

/**
 * Key codes (matching Windows VK_* values for compatibility)
 */
typedef enum KeyCode {
  KEY_CODE_NONE = 0,
  KEY_CODE_BACKSPACE = 8,
  KEY_CODE_TAB = 9,
  KEY_CODE_RETURN = 13,
  KEY_CODE_SHIFT = 16,
  KEY_CODE_CONTROL = 17,
  KEY_CODE_ALT = 18,
  KEY_CODE_PAUSE = 19,
  KEY_CODE_CAPS_LOCK = 20,
  KEY_CODE_ESCAPE = 27,
  KEY_CODE_SPACE = 32,
  KEY_CODE_PAGE_UP = 33,
  KEY_CODE_PAGE_DOWN = 34,
  KEY_CODE_END = 35,
  KEY_CODE_HOME = 36,
  KEY_CODE_LEFT = 37,
  KEY_CODE_UP = 38,
  KEY_CODE_RIGHT = 39,
  KEY_CODE_DOWN = 40,
  KEY_CODE_INSERT = 45,
  KEY_CODE_DELETE = 46,
  KEY_CODE_F1 = 112,
  KEY_CODE_F2 = 113,
  KEY_CODE_F3 = 114,
  KEY_CODE_F4 = 115,
  KEY_CODE_F5 = 116,
  KEY_CODE_F6 = 117,
  KEY_CODE_F7 = 118,
  KEY_CODE_F8 = 119,
  KEY_CODE_F9 = 120,
  KEY_CODE_F10 = 121,
  KEY_CODE_F11 = 122,
  KEY_CODE_F12 = 123,
  KEY_CODE_NUM_LOCK = 144,
  KEY_CODE_SCROLL_LOCK = 145,
} KeyCode;

/**
 * Log level for Platform_Log
 */
typedef enum LogLevel {
  LOG_LEVEL_DEBUG = 0,
  LOG_LEVEL_INFO = 1,
  LOG_LEVEL_WARN = 2,
  LOG_LEVEL_ERROR = 3,
} LogLevel;

/**
 * Mouse button
 */
typedef enum MouseButton {
  MOUSE_BUTTON_LEFT = 0,
  MOUSE_BUTTON_RIGHT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
} MouseButton;

/**
 * Result type for platform operations (FFI-compatible)
 */
typedef enum PlatformResult {
  PLATFORM_RESULT_SUCCESS = 0,
  PLATFORM_RESULT_ALREADY_INITIALIZED = 1,
  PLATFORM_RESULT_NOT_INITIALIZED = 2,
  PLATFORM_RESULT_INIT_FAILED = 3,
} PlatformResult;

/**
 * Seek origin
 */
typedef enum SeekOrigin {
  SEEK_ORIGIN_START = 0,
  SEEK_ORIGIN_CURRENT = 1,
  SEEK_ORIGIN_END = 2,
} SeekOrigin;

/**
 * Network Manager
 *
 * Manages the network session state and provides unified host/client API.
 */
typedef struct NetworkManager NetworkManager;

/**
 * Platform network client
 *
 * Connects to a network host and exchanges packets.
 */
typedef struct PlatformClient PlatformClient;

/**
 * Directory iterator
 */
typedef struct PlatformDir PlatformDir;

/**
 * Platform file handle
 */
typedef struct PlatformFile PlatformFile;

/**
 * Platform network host (server)
 *
 * Wraps an enet::Host and manages peer connections.
 */
typedef struct PlatformHost PlatformHost;

/**
 * Opaque handle to a loaded shape file
 */
typedef struct PlatformShape PlatformShape;

/**
 * Opaque handle to a loaded template file
 */
typedef struct PlatformTemplate PlatformTemplate;

/**
 * Opaque handle to a loaded PCX image
 */
typedef struct PlatformPcx PlatformPcx;

/**
 * Display mode configuration
 */
typedef struct DisplayMode {
  int32_t width;
  int32_t height;
  int32_t bits_per_pixel;
} DisplayMode;

/**
 * RGB palette entry
 */
typedef struct PaletteEntry {
  uint8_t r;
  uint8_t g;
  uint8_t b;
} PaletteEntry;

/**
 * Opaque surface handle for C
 */
typedef struct PlatformSurface {
  uint8_t _private[0];
} PlatformSurface;

/**
 * Timer handle
 */
typedef int32_t TimerHandle;

/**
 * C timer callback type
 */
typedef void (*CTimerCallback)(void*);

/**
 * Directory entry information
 */
typedef struct DirEntry {
  /**
   * Filename (null-terminated, max 260 chars)
   */
  uint8_t name[260];
  /**
   * Is this entry a directory?
   */
  bool is_directory;
  /**
   * File size in bytes (0 for directories)
   */
  int64_t size;
} DirEntry;

/**
 * Audio configuration
 */
typedef struct AudioConfig {
  int32_t sample_rate;
  int32_t channels;
  int32_t bits_per_sample;
  int32_t buffer_size;
} AudioConfig;

/**
 * Sound handle type
 */
typedef int32_t SoundHandle;

/**
 * Playing sound handle
 */
typedef int32_t PlayHandle;

/**
 * Clipping rectangle for blit operations
 *
 * Used to define source regions and handle clipping to destination bounds.
 */
typedef struct ClipRect {
  int32_t x;
  int32_t y;
  int32_t width;
  int32_t height;
} ClipRect;

#define INVALID_SOUND_HANDLE -1

#define INVALID_PLAY_HANDLE -1

#define INVALID_TIMER_HANDLE -1

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the current application state
 *
 * # Returns
 * - 0: Active (foreground)
 * - 1: Background
 * - 2: Terminating
 */
int Platform_GetAppState(void);

/**
 * Check if application is active (foreground)
 *
 * # Returns
 * - 1 if active
 * - 0 if not active (background or terminating)
 */
int Platform_IsAppActive(void);

/**
 * Check if application is in background
 *
 * # Returns
 * - 1 if in background
 * - 0 if not in background
 */
int Platform_IsAppBackground(void);

/**
 * Request application quit
 *
 * Sets a flag that should be checked each frame with Platform_ShouldQuit().
 * The game should save state and exit gracefully.
 */
void Platform_RequestQuit(void);

/**
 * Check if quit has been requested
 *
 * The main game loop should check this each frame:
 * ```c
 * while (!Platform_ShouldQuit()) {
 *     // game loop
 * }
 * ```
 *
 * # Returns
 * - 1 if quit requested
 * - 0 if not
 */
int Platform_ShouldQuit(void);

/**
 * Clear quit request
 *
 * Call if quit was cancelled (e.g., user declined to save).
 */
void Platform_ClearQuitRequest(void);

/**
 * Process application events for lifecycle changes
 *
 * This should be called by the input processing code for each SDL event.
 * It handles app lifecycle events and updates state accordingly.
 *
 * # Returns
 * - The new AppState value if state changed
 * - -1 if no state change
 */
int Platform_HandleAppEvent(void);

/**
 * Get the configuration directory path
 *
 * Copies the path to the provided buffer.
 *
 * # Parameters
 * - `buffer`: Output buffer for null-terminated UTF-8 path string
 * - `buffer_size`: Size of buffer in bytes
 *
 * # Returns
 * - Number of bytes written (excluding null) on success
 * - -1 on error (null buffer or insufficient size)
 *
 * # Example Path
 * `/Users/username/Library/Application Support/RedAlert`
 */
int32_t Platform_GetConfigPath(char *buffer, int32_t buffer_size);

/**
 * Get the saves directory path
 *
 * # Parameters
 * - `buffer`: Output buffer for null-terminated UTF-8 path string
 * - `buffer_size`: Size of buffer in bytes
 *
 * # Returns
 * - Number of bytes written (excluding null) on success
 * - -1 on error
 *
 * # Example Path
 * `/Users/username/Library/Application Support/RedAlert/saves`
 */
int32_t Platform_GetSavesPath(char *buffer, int32_t buffer_size);

/**
 * Get the log files directory path
 *
 * # Parameters
 * - `buffer`: Output buffer for null-terminated UTF-8 path string
 * - `buffer_size`: Size of buffer in bytes
 *
 * # Returns
 * - Number of bytes written (excluding null) on success
 * - -1 on error
 *
 * # Example Path
 * `/Users/username/Library/Application Support/RedAlert/logs`
 */
int32_t Platform_GetLogPath(char *buffer, int32_t buffer_size);

/**
 * Get the cache directory path
 *
 * # Parameters
 * - `buffer`: Output buffer for null-terminated UTF-8 path string
 * - `buffer_size`: Size of buffer in bytes
 *
 * # Returns
 * - Number of bytes written (excluding null) on success
 * - -1 on error
 *
 * # Example Path
 * `/Users/username/Library/Caches/RedAlert`
 */
int32_t Platform_GetCachePath(char *buffer, int32_t buffer_size);

/**
 * Get the game data directory path
 *
 * Searches for data in standard locations and returns the first that exists.
 *
 * # Parameters
 * - `buffer`: Output buffer for null-terminated UTF-8 path string
 * - `buffer_size`: Size of buffer in bytes
 *
 * # Returns
 * - Number of bytes written (excluding null) on success
 * - -1 on error
 *
 * # Search Order
 * 1. App bundle Resources/data/
 * 2. ./data/
 * 3. ../data/
 */
int32_t Platform_GetDataPath(char *buffer, int32_t buffer_size);

/**
 * Ensure all configuration directories exist
 *
 * Creates the config, saves, logs, and cache directories if they don't exist.
 *
 * # Returns
 * - 0 on success (all directories exist or were created)
 * - -1 on error (failed to create one or more directories)
 */
int32_t Platform_EnsureDirectories(void);

/**
 * Initialize the platform layer
 */
enum PlatformResult Platform_Init(void);

/**
 * Shutdown the platform layer
 */
enum PlatformResult Platform_Shutdown(void);

/**
 * Check if platform is initialized
 */
bool Platform_IsInitialized(void);

/**
 * Get platform version
 */
int32_t Platform_GetVersion(void);

/**
 * Get the last error message into a buffer
 * Returns number of bytes written, or -1 on error
 * Buffer will be null-terminated if there's space
 */
int32_t Platform_GetLastError(int8_t *buffer, int32_t buffer_size);

/**
 * Get error as static string pointer (valid until next error)
 * Returns null if no error
 */
const char *Platform_GetErrorString(void);

/**
 * Set an error message from C string
 */
void Platform_SetError(const char *msg);

/**
 * Clear the last error
 */
void Platform_ClearError(void);

/**
 * Log a message at the specified level
 * Uses the new logging infrastructure from crate::logging
 */
void Platform_Log(enum LogLevel level, const char *msg);

/**
 * Log a formatted debug message
 */
void Platform_LogDebug(const char *msg);

/**
 * Log a formatted info message
 */
void Platform_LogInfo(const char *msg);

/**
 * Log a formatted warning message
 */
void Platform_LogWarn(const char *msg);

/**
 * Log a formatted error message
 */
void Platform_LogError(const char *msg);

/**
 * Initialize graphics subsystem
 */
int32_t Platform_Graphics_Init(void);

/**
 * Shutdown graphics subsystem
 */
void Platform_Graphics_Shutdown(void);

/**
 * Check if graphics is initialized
 */
bool Platform_Graphics_IsInitialized(void);

/**
 * Clear screen with color (for testing)
 */
void Platform_Graphics_Clear(uint8_t r, uint8_t g, uint8_t b);

/**
 * Present the frame
 */
void Platform_Graphics_Present(void);

/**
 * Get display mode
 */
void Platform_Graphics_GetMode(struct DisplayMode *mode);

/**
 * Get back buffer for direct pixel access
 * Returns pointer to 8-bit indexed pixel buffer
 */
int32_t Platform_Graphics_GetBackBuffer(uint8_t **pixels,
                                        int32_t *width,
                                        int32_t *height,
                                        int32_t *pitch);

/**
 * Clear back buffer with color index
 */
void Platform_Graphics_ClearBackBuffer(uint8_t color);

/**
 * Set palette entries
 */
void Platform_Graphics_SetPalette(const struct PaletteEntry *entries, int32_t start, int32_t count);

/**
 * Get palette entries
 */
void Platform_Graphics_GetPalette(struct PaletteEntry *entries, int32_t start, int32_t count);

/**
 * Set single palette entry
 */
void Platform_Graphics_SetPaletteEntry(uint8_t index, uint8_t r, uint8_t g, uint8_t b);

/**
 * Fade palette (0.0 = black, 1.0 = full)
 */
void Platform_Graphics_FadePalette(float factor);

/**
 * Restore palette from fade
 */
void Platform_Graphics_RestorePalette(void);

/**
 * Flip back buffer to screen (full render pipeline)
 */
int32_t Platform_Graphics_Flip(void);

/**
 * Wait for vertical sync (no-op, handled by SDL)
 */
void Platform_Graphics_WaitVSync(void);

/**
 * Draw test pattern to back buffer (for testing)
 */
void Platform_Graphics_DrawTestPattern(void);

/**
 * Get free video memory (returns large value for compatibility)
 */
uint32_t Platform_Graphics_GetFreeVideoMemory(void);

/**
 * Check if hardware accelerated
 */
bool Platform_Graphics_IsHardwareAccelerated(void);

/**
 * Poll events and return true if quit was requested (window close or Escape key)
 */
bool Platform_PollEvents(void);

/**
 * Get tick count in milliseconds since SDL init
 */
uint32_t Platform_GetTicks(void);

/**
 * Delay for specified milliseconds
 */
void Platform_Delay(uint32_t ms);

/**
 * Create a new surface
 */
struct PlatformSurface *Platform_Surface_Create(int32_t width, int32_t height, int32_t bpp);

/**
 * Destroy a surface
 */
void Platform_Surface_Destroy(struct PlatformSurface *surface);

/**
 * Get surface dimensions
 */
void Platform_Surface_GetSize(const struct PlatformSurface *surface,
                              int32_t *width,
                              int32_t *height);

/**
 * Lock surface for direct pixel access
 */
int32_t Platform_Surface_Lock(struct PlatformSurface *surface, void **pixels, int32_t *pitch);

/**
 * Unlock surface
 */
void Platform_Surface_Unlock(struct PlatformSurface *surface);

/**
 * Blit surface to another
 */
int32_t Platform_Surface_Blit(struct PlatformSurface *dest,
                              int32_t dx,
                              int32_t dy,
                              const struct PlatformSurface *src,
                              int32_t sx,
                              int32_t sy,
                              int32_t sw,
                              int32_t sh);

/**
 * Blit with transparency (skip color 0)
 */
int32_t Platform_Surface_BlitTransparent(struct PlatformSurface *dest,
                                         int32_t dx,
                                         int32_t dy,
                                         const struct PlatformSurface *src,
                                         int32_t sx,
                                         int32_t sy,
                                         int32_t sw,
                                         int32_t sh);

/**
 * Fill rectangle
 */
void Platform_Surface_Fill(struct PlatformSurface *surface,
                           int32_t x,
                           int32_t y,
                           int32_t w,
                           int32_t h,
                           uint8_t color);

/**
 * Clear entire surface
 */
void Platform_Surface_Clear(struct PlatformSurface *surface, uint8_t color);

/**
 * Initialize input subsystem
 */
int32_t Platform_Input_Init(void);

/**
 * Shutdown input subsystem
 */
void Platform_Input_Shutdown(void);

/**
 * Update input state (call at start of each frame)
 */
void Platform_Input_Update(void);

/**
 * Check if quit was requested
 */
bool Platform_Input_ShouldQuit(void);

/**
 * Check if key is currently pressed
 */
bool Platform_Key_IsPressed(enum KeyCode key);

/**
 * Check if key was just pressed this frame
 */
bool Platform_Key_WasPressed(enum KeyCode key);

/**
 * Check if key was just released this frame
 */
bool Platform_Key_WasReleased(enum KeyCode key);

/**
 * Get next key event from queue (returns false if empty)
 */
bool Platform_Key_GetNext(enum KeyCode *key, bool *released);

/**
 * Clear key event queue
 */
void Platform_Key_Clear(void);

/**
 * Check if Shift is held
 */
bool Platform_Key_ShiftDown(void);

/**
 * Check if Ctrl is held
 */
bool Platform_Key_CtrlDown(void);

/**
 * Check if Alt is held
 */
bool Platform_Key_AltDown(void);

/**
 * Get mouse position
 */
void Platform_Mouse_GetPosition(int32_t *x, int32_t *y);

/**
 * Get mouse X position
 */
int32_t Platform_Mouse_GetX(void);

/**
 * Get mouse Y position
 */
int32_t Platform_Mouse_GetY(void);

/**
 * Check if mouse button is pressed
 */
bool Platform_Mouse_IsPressed(enum MouseButton button);

/**
 * Check if mouse button was clicked this frame
 */
bool Platform_Mouse_WasClicked(enum MouseButton button);

/**
 * Check if mouse button was double-clicked this frame
 */
bool Platform_Mouse_WasDoubleClicked(enum MouseButton button);

/**
 * Get mouse wheel delta
 */
int32_t Platform_Mouse_GetWheelDelta(void);

/**
 * Show mouse cursor
 */
void Platform_Mouse_Show(void);

/**
 * Hide mouse cursor
 */
void Platform_Mouse_Hide(void);

/**
 * Get milliseconds since platform init
 */
uint32_t Platform_Timer_GetTicks(void);

/**
 * Sleep for milliseconds
 */
void Platform_Timer_Delay(uint32_t milliseconds);

/**
 * Get high-resolution performance counter
 */
uint64_t Platform_Timer_GetPerformanceCounter(void);

/**
 * Get performance counter frequency
 */
uint64_t Platform_Timer_GetPerformanceFrequency(void);

/**
 * Get time in seconds (floating point)
 */
double Platform_Timer_GetTime(void);

/**
 * Create a periodic timer
 * Note: The callback will be called from a separate thread!
 */
TimerHandle Platform_Timer_Create(uint32_t interval_ms, CTimerCallback callback, void *userdata);

/**
 * Destroy a periodic timer
 */
void Platform_Timer_Destroy(TimerHandle handle);

/**
 * Get invalid timer handle constant
 */
TimerHandle Platform_Timer_InvalidHandle(void);

/**
 * Start frame timing
 */
void Platform_Frame_Begin(void);

/**
 * End frame timing (sleeps to maintain target FPS)
 */
void Platform_Frame_End(void);

/**
 * Set target FPS
 */
void Platform_Frame_SetTargetFPS(uint32_t fps);

/**
 * Get last frame time in seconds
 */
double Platform_Frame_GetTime(void);

/**
 * Get current FPS (rolling average)
 */
double Platform_Frame_GetFPS(void);

/**
 * Allocate memory
 */
void *Platform_Alloc(uintptr_t size, uint32_t flags);

/**
 * Free memory
 */
void Platform_Free(void *ptr, uintptr_t size);

/**
 * Reallocate memory
 */
void *Platform_Realloc(void *ptr, uintptr_t old_size, uintptr_t new_size);

/**
 * Get free RAM (returns large value for compatibility)
 */
uintptr_t Platform_Ram_Free(void);

/**
 * Get total RAM
 */
uintptr_t Platform_Ram_Total(void);

/**
 * Get current allocation total
 */
uintptr_t Platform_Mem_GetAllocated(void);

/**
 * Get peak allocation
 */
uintptr_t Platform_Mem_GetPeak(void);

/**
 * Get allocation count
 */
uintptr_t Platform_Mem_GetCount(void);

/**
 * Dump leaks (debug only)
 */
void Platform_Mem_DumpLeaks(void);

/**
 * Copy memory (memcpy) - non-overlapping
 */
void Platform_MemCopy(void *dest, const void *src, uintptr_t count);

/**
 * Move memory (memmove) - handles overlapping
 */
void Platform_MemMove(void *dest, const void *src, uintptr_t count);

/**
 * Set memory (memset)
 */
void Platform_MemSet(void *dest, int32_t value, uintptr_t count);

/**
 * Compare memory (memcmp)
 */
int32_t Platform_MemCmp(const void *s1, const void *s2, uintptr_t count);

/**
 * Zero memory
 */
void Platform_ZeroMemory(void *dest, uintptr_t count);

/**
 * Get base path (executable directory)
 */
const char *Platform_GetBasePath(void);

/**
 * Get preferences path (user data directory)
 */
const char *Platform_GetPrefPath(void);

/**
 * Initialize file system
 */
void Platform_Files_Init(const char *org_name, const char *app_name);

/**
 * Normalize a path (convert Windows to Unix style, modifies in place)
 */
void Platform_NormalizePath(char *path);

/**
 * Open a file
 */
struct PlatformFile *Platform_File_Open(const char *path, enum FileMode mode);

/**
 * Close a file
 */
void Platform_File_Close(struct PlatformFile *file);

/**
 * Read from file
 */
int32_t Platform_File_Read(struct PlatformFile *file, void *buffer, int32_t size);

/**
 * Write to file
 */
int32_t Platform_File_Write(struct PlatformFile *file, const void *buffer, int32_t size);

/**
 * Seek in file
 */
int32_t Platform_File_Seek(struct PlatformFile *file, int64_t offset, enum SeekOrigin origin);

/**
 * Get file position
 */
int64_t Platform_File_Tell(struct PlatformFile *file);

/**
 * Get file size
 */
int64_t Platform_File_Size(const struct PlatformFile *file);

/**
 * Check if at end of file
 */
bool Platform_File_Eof(struct PlatformFile *file);

/**
 * Flush file buffers
 */
bool Platform_File_Flush(struct PlatformFile *file);

/**
 * Check if file exists
 */
bool Platform_File_Exists(const char *path);

/**
 * Get file size without opening
 */
int64_t Platform_File_GetSize(const char *path);

/**
 * Delete a file
 */
bool Platform_File_Delete(const char *path);

/**
 * Copy a file
 */
int64_t Platform_File_Copy(const char *src, const char *dst);

/**
 * Open a directory for iteration
 */
struct PlatformDir *Platform_Dir_Open(const char *path);

/**
 * Read next directory entry
 */
bool Platform_Dir_Read(struct PlatformDir *dir, struct DirEntry *entry);

/**
 * Close directory
 */
void Platform_Dir_Close(struct PlatformDir *dir);

/**
 * Check if path is a directory
 */
bool Platform_IsDirectory(const char *path);

/**
 * Create a directory
 */
bool Platform_CreateDirectory(const char *path);

/**
 * Delete a directory
 */
bool Platform_DeleteDirectory(const char *path);

/**
 * Initialize audio subsystem
 */
int32_t Platform_Audio_Init(const struct AudioConfig *config);

/**
 * Shutdown audio subsystem
 */
void Platform_Audio_Shutdown(void);

/**
 * Check if audio is initialized
 */
bool Platform_Audio_IsInitialized(void);

/**
 * Set master volume (0.0 to 1.0)
 */
void Platform_Audio_SetMasterVolume(float volume);

/**
 * Get master volume
 */
float Platform_Audio_GetMasterVolume(void);

/**
 * Create a sound from raw PCM data in memory
 */
SoundHandle Platform_Sound_CreateFromMemory(const void *data,
                                            int32_t size,
                                            int32_t sample_rate,
                                            int32_t channels,
                                            int32_t bits_per_sample);

/**
 * Destroy a sound
 */
void Platform_Sound_Destroy(SoundHandle handle);

/**
 * Get number of loaded sounds
 */
int32_t Platform_Sound_GetCount(void);

/**
 * Play a sound
 */
PlayHandle Platform_Sound_Play(SoundHandle handle, float volume, float pan, bool looping);

/**
 * Stop a playing sound
 */
void Platform_Sound_Stop(PlayHandle handle);

/**
 * Stop all playing sounds
 */
void Platform_Sound_StopAll(void);

/**
 * Check if a sound is playing
 */
bool Platform_Sound_IsPlaying(PlayHandle handle);

/**
 * Set volume of a playing sound
 */
void Platform_Sound_SetVolume(PlayHandle handle, float volume);

/**
 * Pause a playing sound
 */
void Platform_Sound_Pause(PlayHandle handle);

/**
 * Resume a paused sound
 */
void Platform_Sound_Resume(PlayHandle handle);

/**
 * Get number of currently playing sounds
 */
int32_t Platform_Sound_GetPlayingCount(void);

/**
 * Create a sound from ADPCM compressed data
 */
SoundHandle Platform_Sound_CreateFromADPCM(const void *data,
                                           int32_t size,
                                           int32_t sample_rate,
                                           int32_t channels);

/**
 * Create a sound from ADPCM data with initial decoder state
 */
SoundHandle Platform_Sound_CreateFromADPCMWithState(const void *data,
                                                    int32_t size,
                                                    int32_t sample_rate,
                                                    int32_t channels,
                                                    int32_t predictor,
                                                    int32_t step_index);

/**
 * Clear buffer with a single value
 *
 * # Safety
 * - `buffer` must point to valid memory of at least `size` bytes
 */
void Platform_Buffer_Clear(uint8_t *buffer, int32_t size, uint8_t value);

/**
 * Fill rectangular region with a value
 *
 * # Safety
 * - `buffer` must point to valid memory of at least `pitch * buf_height` bytes
 */
void Platform_Buffer_FillRect(uint8_t *buffer,
                              int32_t pitch,
                              int32_t buf_width,
                              int32_t buf_height,
                              int32_t x,
                              int32_t y,
                              int32_t width,
                              int32_t height,
                              uint8_t value);

/**
 * Draw horizontal line
 *
 * # Safety
 * - `buffer` must point to valid memory of at least `pitch * buf_height` bytes
 */
void Platform_Buffer_HLine(uint8_t *buffer,
                           int32_t pitch,
                           int32_t buf_width,
                           int32_t buf_height,
                           int32_t x,
                           int32_t y,
                           int32_t length,
                           uint8_t color);

/**
 * Draw vertical line
 *
 * # Safety
 * - `buffer` must point to valid memory of at least `pitch * buf_height` bytes
 */
void Platform_Buffer_VLine(uint8_t *buffer,
                           int32_t pitch,
                           int32_t buf_width,
                           int32_t buf_height,
                           int32_t x,
                           int32_t y,
                           int32_t length,
                           uint8_t color);

/**
 * Blit from source buffer to destination (opaque)
 *
 * # Safety
 * - `dest` must point to valid memory of at least `dest_pitch * dest_height` bytes
 * - `src` must point to valid memory of at least `src_pitch * src_height` bytes
 */
void Platform_Buffer_ToBuffer(uint8_t *dest,
                              int32_t dest_pitch,
                              int32_t dest_width,
                              int32_t dest_height,
                              const uint8_t *src,
                              int32_t src_pitch,
                              int32_t src_width,
                              int32_t src_height,
                              int32_t dest_x,
                              int32_t dest_y,
                              int32_t src_x,
                              int32_t src_y,
                              int32_t width,
                              int32_t height);

/**
 * Blit with transparency (color 0 = transparent)
 *
 * # Safety
 * Same as Platform_Buffer_ToBuffer
 */
void Platform_Buffer_ToBufferTrans(uint8_t *dest,
                                   int32_t dest_pitch,
                                   int32_t dest_width,
                                   int32_t dest_height,
                                   const uint8_t *src,
                                   int32_t src_pitch,
                                   int32_t src_width,
                                   int32_t src_height,
                                   int32_t dest_x,
                                   int32_t dest_y,
                                   int32_t src_x,
                                   int32_t src_y,
                                   int32_t width,
                                   int32_t height);

/**
 * Blit with custom transparent color key
 *
 * # Safety
 * Same as Platform_Buffer_ToBuffer
 */
void Platform_Buffer_ToBufferTransKey(uint8_t *dest,
                                      int32_t dest_pitch,
                                      int32_t dest_width,
                                      int32_t dest_height,
                                      const uint8_t *src,
                                      int32_t src_pitch,
                                      int32_t src_width,
                                      int32_t src_height,
                                      int32_t dest_x,
                                      int32_t dest_y,
                                      int32_t src_x,
                                      int32_t src_y,
                                      int32_t width,
                                      int32_t height,
                                      uint8_t transparent_color);

/**
 * Apply remap table to buffer region
 *
 * # Safety
 * - `buffer` must point to valid memory of at least `pitch * (y + height)` bytes
 * - `remap_table` must point to exactly 256 bytes
 */
void Platform_Buffer_Remap(uint8_t *buffer,
                           int32_t pitch,
                           int32_t x,
                           int32_t y,
                           int32_t width,
                           int32_t height,
                           const uint8_t *remap_table);

/**
 * Apply remap table with transparency (skip color 0)
 *
 * # Safety
 * Same as Platform_Buffer_Remap
 */
void Platform_Buffer_RemapTrans(uint8_t *buffer,
                                int32_t pitch,
                                int32_t x,
                                int32_t y,
                                int32_t width,
                                int32_t height,
                                const uint8_t *remap_table);

/**
 * Remap from source to destination
 *
 * # Safety
 * - `dest` must point to valid memory
 * - `src` must point to valid memory
 * - `remap_table` must point to exactly 256 bytes
 */
void Platform_Buffer_RemapCopy(uint8_t *dest,
                               int32_t dest_pitch,
                               int32_t dest_x,
                               int32_t dest_y,
                               const uint8_t *src,
                               int32_t src_pitch,
                               int32_t src_x,
                               int32_t src_y,
                               int32_t width,
                               int32_t height,
                               const uint8_t *remap_table);

/**
 * Scale buffer using nearest-neighbor interpolation
 *
 * # Safety
 * - `dest` must point to valid memory of at least `dest_pitch * dest_height` bytes
 * - `src` must point to valid memory of at least `src_pitch * src_height` bytes
 */
void Platform_Buffer_Scale(uint8_t *dest,
                           int32_t dest_pitch,
                           int32_t dest_width,
                           int32_t dest_height,
                           const uint8_t *src,
                           int32_t src_pitch,
                           int32_t src_width,
                           int32_t src_height,
                           int32_t dest_x,
                           int32_t dest_y,
                           int32_t scale_width,
                           int32_t scale_height);

/**
 * Scale buffer with transparency (skip color 0)
 *
 * # Safety
 * Same as Platform_Buffer_Scale
 */
void Platform_Buffer_ScaleTrans(uint8_t *dest,
                                int32_t dest_pitch,
                                int32_t dest_width,
                                int32_t dest_height,
                                const uint8_t *src,
                                int32_t src_pitch,
                                int32_t src_width,
                                int32_t src_height,
                                int32_t dest_x,
                                int32_t dest_y,
                                int32_t scale_width,
                                int32_t scale_height);

/**
 * Scale buffer with custom transparent color
 *
 * # Safety
 * Same as Platform_Buffer_Scale
 */
void Platform_Buffer_ScaleTransKey(uint8_t *dest,
                                   int32_t dest_pitch,
                                   int32_t dest_width,
                                   int32_t dest_height,
                                   const uint8_t *src,
                                   int32_t src_pitch,
                                   int32_t src_width,
                                   int32_t src_height,
                                   int32_t dest_x,
                                   int32_t dest_y,
                                   int32_t scale_width,
                                   int32_t scale_height,
                                   uint8_t transparent_color);

/**
 * Apply shadow to rectangular region
 *
 * # Safety
 * - `buffer` must point to valid memory
 * - `shadow_table` must point to exactly 256 bytes
 */
void Platform_Buffer_Shadow(uint8_t *buffer,
                            int32_t pitch,
                            int32_t x,
                            int32_t y,
                            int32_t width,
                            int32_t height,
                            const uint8_t *shadow_table);

/**
 * Apply shadow using mask sprite
 *
 * # Safety
 * - `buffer` must point to valid memory
 * - `mask` must point to valid memory of at least `mask_pitch * height` bytes
 * - `shadow_table` must point to exactly 256 bytes
 */
void Platform_Buffer_ShadowMask(uint8_t *buffer,
                                int32_t buffer_pitch,
                                int32_t buffer_width,
                                int32_t buffer_height,
                                const uint8_t *mask,
                                int32_t mask_pitch,
                                int32_t x,
                                int32_t y,
                                int32_t width,
                                int32_t height,
                                const uint8_t *shadow_table);

/**
 * Generate shadow lookup table from palette
 *
 * # Safety
 * - `palette` must point to 768 bytes (256 RGB triplets)
 * - `shadow_table` must point to 256 bytes for output
 */
void Platform_GenerateShadowTable(const uint8_t *palette, uint8_t *shadow_table, float intensity);

/**
 * Decompress LCW-encoded data
 *
 * # Arguments
 * * `source` - Pointer to compressed data
 * * `source_size` - Size of compressed data
 * * `dest` - Pointer to output buffer
 * * `dest_size` - Size of output buffer
 *
 * # Returns
 * Number of bytes written, or -1 on error
 *
 * # Safety
 * - `source` must point to valid memory of at least `source_size` bytes
 * - `dest` must point to valid memory of at least `dest_size` bytes
 */
int32_t Platform_LCW_Decompress(const uint8_t *source,
                                int32_t source_size,
                                uint8_t *dest,
                                int32_t dest_size);

/**
 * Compress data using LCW algorithm
 *
 * # Arguments
 * * `source` - Pointer to uncompressed data
 * * `source_size` - Size of uncompressed data
 * * `dest` - Pointer to output buffer
 * * `dest_size` - Size of output buffer
 *
 * # Returns
 * Number of bytes written, or -1 on error
 *
 * # Safety
 * - `source` must point to valid memory of at least `source_size` bytes
 * - `dest` must point to valid memory of at least `dest_size` bytes
 */
int32_t Platform_LCW_Compress(const uint8_t *source,
                              int32_t source_size,
                              uint8_t *dest,
                              int32_t dest_size);

/**
 * Calculate maximum compressed size for given input size
 *
 * Use this to allocate output buffer for compression.
 */
int32_t Platform_LCW_MaxCompressedSize(int32_t uncompressed_size);

/**
 * Calculate CRC32 of data
 *
 * # Safety
 * - `data` must point to valid memory of at least `size` bytes
 */
uint32_t Platform_CRC32(const uint8_t *data, int32_t size);

/**
 * Update CRC32 with more data (for streaming)
 *
 * # Arguments
 * * `crc` - Previous CRC value (use 0xFFFFFFFF for first call)
 * * `data` - Pointer to data
 * * `size` - Size of data
 *
 * # Returns
 * Updated CRC (call Platform_CRC32_Finalize when done)
 *
 * # Safety
 * - `data` must point to valid memory of at least `size` bytes
 */
uint32_t Platform_CRC32_Update(uint32_t crc_val, const uint8_t *data, int32_t size);

/**
 * Finalize CRC32 calculation
 *
 * XORs with 0xFFFFFFFF to produce final value.
 */
uint32_t Platform_CRC32_Finalize(uint32_t crc_val);

/**
 * Get initial CRC32 value for streaming
 */
uint32_t Platform_CRC32_Init(void);

/**
 * Calculate Westwood CRC (rotate-and-add hash) for MIX file lookups.
 *
 * This is NOT a standard CRC - it's Westwood's custom filename hash algorithm.
 * The result is used to look up files in MIX archives via binary search.
 *
 * # Safety
 * - `data` must point to valid memory of at least `size` bytes
 */
uint32_t Platform_Westwood_CRC(const uint8_t *data, int32_t size);

/**
 * Calculate Westwood CRC for a filename string.
 *
 * The filename is automatically converted to uppercase before hashing,
 * as MIX files use case-insensitive lookups.
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 */
uint32_t Platform_Westwood_CRC_Filename(const char *filename);

/**
 * Seed the global random number generator
 */
void Platform_Random_Seed(uint32_t seed);

/**
 * Get the current random seed
 */
uint32_t Platform_Random_GetSeed(void);

/**
 * Get next random number (0-32767)
 */
uint32_t Platform_Random_Get(void);

/**
 * Get random number in range [min, max]
 */
int32_t Platform_Random_Range(int32_t min, int32_t max);

/**
 * Get random number in range [0, max)
 */
uint32_t Platform_Random_Max(uint32_t max);

/**
 * Initialize the asset system
 *
 * This is optional - the MIX manager is initialized lazily.
 */
int32_t Platform_Assets_Init(void);

/**
 * Register a MIX file with the asset system
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 *
 * # Returns
 * - 0 on success
 * - -1 on error (file not found, invalid format, etc.)
 */
int32_t Platform_Mix_Register(const char *path);

/**
 * Register and cache a MIX file
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 *
 * # Returns
 * - 0 on success
 * - -1 on error
 */
int32_t Platform_Mix_RegisterAndCache(const char *path);

/**
 * Unregister a MIX file
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 *
 * # Returns
 * - 1 if found and removed
 * - 0 if not found
 * - -1 on error
 */
int32_t Platform_Mix_Unregister(const char *path);

/**
 * Check if a file exists in any registered MIX
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 *
 * # Returns
 * - 1 if file exists
 * - 0 if not found
 */
int32_t Platform_Mix_Exists(const char *filename);

/**
 * Read file data from MIX archives
 *
 * The data is copied to the provided buffer.
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 * - `buffer` must point to at least `buffer_size` bytes
 *
 * # Returns
 * - Number of bytes read on success
 * - 0 if file not found
 * - -1 on error
 */
int32_t Platform_Mix_Read(const char *filename, uint8_t *buffer, int32_t buffer_size);

/**
 * Get the size of a file in MIX archives
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 *
 * # Returns
 * - File size in bytes on success
 * - 0 if not found
 * - -1 on error
 */
int32_t Platform_Mix_GetSize(const char *filename);

/**
 * Get number of registered MIX files
 */
int32_t Platform_Mix_GetCount(void);

/**
 * Register a nested MIX file
 *
 * Extracts a MIX file that's stored inside another registered MIX file
 * and registers it so its contents can be accessed.
 *
 * For example, MAIN.MIX contains conquer.mix and local.mix which need to be
 * extracted and registered to access their contents like TITLE.PCX.
 *
 * @param nested_name Name of the nested MIX file (e.g., "local.mix")
 * @return Number of files in the nested MIX on success, 0 if not found, -1 on error
 */
int32_t Platform_Mix_RegisterNested(const char *nested_name);

/**
 * Debug: Dump all entries in all registered MIX files to stderr
 *
 * This is for debugging hash lookup issues.
 */
void Platform_Mix_DumpEntries(void);

/**
 * Load a palette from raw PAL data
 *
 * PAL data uses 6-bit color values (0-63), which are shifted to 8-bit (0-252).
 *
 * # Safety
 * - `pal_data` must point to exactly 768 bytes
 * - `output` must point to 768 bytes (256 × 3 RGB)
 *
 * # Returns
 * - 0 on success
 * - -1 on error
 */
int32_t Platform_Palette_LoadPAL(const uint8_t *pal_data, uint8_t *output);

/**
 * Load a palette from a file in MIX archives
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 * - `output` must point to 768 bytes (256 × 3 RGB)
 *
 * # Returns
 * - 0 on success
 * - -1 on error
 */
int32_t Platform_Palette_Load(const char *filename, uint8_t *output);

/**
 * Load a shape file from MIX archives
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 *
 * # Returns
 * - Pointer to loaded shape on success
 * - null on error
 */
struct PlatformShape *Platform_Shape_Load(const char *filename);

/**
 * Load a shape file from raw data
 *
 * # Safety
 * - `data` must point to at least `size` bytes
 *
 * # Returns
 * - Pointer to loaded shape on success
 * - null on error
 */
struct PlatformShape *Platform_Shape_LoadFromMemory(const uint8_t *data, int32_t size);

/**
 * Free a loaded shape file
 *
 * # Safety
 * - `shape` must be a valid pointer from Platform_Shape_Load/LoadFromMemory
 */
void Platform_Shape_Free(struct PlatformShape *shape);

/**
 * Get shape dimensions
 *
 * # Safety
 * - `shape` must be a valid shape pointer
 */
void Platform_Shape_GetSize(const struct PlatformShape *shape, int32_t *width, int32_t *height);

/**
 * Get number of frames in a shape
 *
 * # Safety
 * - `shape` must be a valid shape pointer
 */
int32_t Platform_Shape_GetFrameCount(const struct PlatformShape *shape);

/**
 * Get frame pixel data
 *
 * Copies frame pixels to the provided buffer.
 *
 * # Safety
 * - `shape` must be a valid shape pointer
 * - `buffer` must point to at least width * height bytes
 *
 * # Returns
 * - Number of bytes copied on success
 * - 0 if frame index is invalid
 * - -1 on error
 */
int32_t Platform_Shape_GetFrame(const struct PlatformShape *shape,
                                int32_t frame_index,
                                uint8_t *buffer,
                                int32_t buffer_size);

/**
 * Load a template file from raw data
 *
 * # Safety
 * - `data` must point to at least `size` bytes
 *
 * # Returns
 * - Pointer to loaded template on success
 * - null on error
 */
struct PlatformTemplate *Platform_Template_LoadFromMemory(const uint8_t *data,
                                                          int32_t size,
                                                          int32_t tile_width,
                                                          int32_t tile_height);

/**
 * Free a loaded template file
 *
 * # Safety
 * - `template` must be a valid pointer from Platform_Template_LoadFromMemory
 */
void Platform_Template_Free(struct PlatformTemplate *template_);

/**
 * Get number of tiles in a template
 *
 * # Safety
 * - `template` must be a valid template pointer
 */
int32_t Platform_Template_GetTileCount(const struct PlatformTemplate *template_);

/**
 * Get tile dimensions
 *
 * # Safety
 * - `template` must be a valid template pointer
 */
void Platform_Template_GetTileSize(const struct PlatformTemplate *template_,
                                   int32_t *width,
                                   int32_t *height);

/**
 * Get tile pixel data
 *
 * # Safety
 * - `template` must be a valid template pointer
 * - `buffer` must point to at least tile_width * tile_height bytes
 *
 * # Returns
 * - Number of bytes copied on success
 * - 0 if tile index is invalid
 * - -1 on error
 */
int32_t Platform_Template_GetTile(const struct PlatformTemplate *template_,
                                  int32_t tile_index,
                                  uint8_t *buffer,
                                  int32_t buffer_size);

// =============================================================================
// PCX Image Loading
// =============================================================================

/**
 * Load a PCX image from MIX archives
 *
 * # Safety
 * - `filename` must be a valid null-terminated C string
 *
 * # Returns
 * - Pointer to loaded PCX on success
 * - null on error
 */
struct PlatformPcx *Platform_PCX_Load(const char *filename);

/**
 * Load a PCX image from raw data
 *
 * # Safety
 * - `data` must point to at least `size` bytes
 *
 * # Returns
 * - Pointer to loaded PCX on success
 * - null on error
 */
struct PlatformPcx *Platform_PCX_LoadFromMemory(const uint8_t *data, int32_t size);

/**
 * Free a loaded PCX image
 *
 * # Safety
 * - `pcx` must be a valid pointer from Platform_PCX_Load/LoadFromMemory
 */
void Platform_PCX_Free(struct PlatformPcx *pcx);

/**
 * Get PCX image dimensions
 *
 * # Safety
 * - `pcx` must be a valid PCX pointer
 */
void Platform_PCX_GetSize(const struct PlatformPcx *pcx, int32_t *width, int32_t *height);

/**
 * Get PCX pixel data
 *
 * # Safety
 * - `pcx` must be a valid PCX pointer
 * - `buffer` must point to at least width * height bytes
 *
 * # Returns
 * - Number of bytes copied on success
 * - -1 on error
 */
int32_t Platform_PCX_GetPixels(const struct PlatformPcx *pcx, uint8_t *buffer, int32_t buffer_size);

/**
 * Get PCX palette data (768 bytes, 256 RGB triplets)
 *
 * # Safety
 * - `pcx` must be a valid PCX pointer
 * - `palette` must point to at least 768 bytes
 *
 * # Returns
 * - 0 on success
 * - -1 on error
 */
int32_t Platform_PCX_GetPalette(const struct PlatformPcx *pcx, uint8_t *palette);

/**
 * Check if running on a Retina/HiDPI display
 *
 * # Returns
 * - 1 if Retina display (scale factor > 1)
 * - 0 if standard display
 * - -1 if graphics not initialized
 */
int Platform_IsRetinaDisplay(void);

/**
 * Get the display scale factor
 *
 * On Retina displays, this is typically 2.0.
 * On standard displays, this is 1.0.
 *
 * # Parameters
 * - `scale_x`: Output pointer for X scale factor (nullable)
 * - `scale_y`: Output pointer for Y scale factor (nullable)
 *
 * # Returns
 * - 0 on success
 * - -1 if graphics not initialized
 */
int Platform_GetDisplayScale(float *scale_x, float *scale_y);

/**
 * Toggle fullscreen mode
 *
 * Switches between windowed and desktop fullscreen.
 *
 * # Returns
 * - 0 on success
 * - -1 if failed or graphics not initialized
 */
int Platform_ToggleFullscreen(void);

/**
 * Set fullscreen mode explicitly
 *
 * # Parameters
 * - `fullscreen`: 0 for windowed, non-zero for fullscreen
 *
 * # Returns
 * - 0 on success
 * - -1 if failed or graphics not initialized
 */
int Platform_SetFullscreen(int fullscreen);

/**
 * Check if currently in fullscreen mode
 *
 * # Returns
 * - 1 if fullscreen
 * - 0 if windowed
 * - -1 if graphics not initialized
 */
int Platform_IsFullscreen(void);

/**
 * Get window size in logical pixels (points)
 *
 * # Parameters
 * - `width`: Output pointer for width (nullable)
 * - `height`: Output pointer for height (nullable)
 *
 * # Returns
 * - 0 on success
 * - -1 if graphics not initialized
 */
int Platform_GetWindowSize(int *width, int *height);

/**
 * Get drawable size in physical pixels
 *
 * On Retina displays, this is larger than window size.
 *
 * # Parameters
 * - `width`: Output pointer for width (nullable)
 * - `height`: Output pointer for height (nullable)
 *
 * # Returns
 * - 0 on success
 * - -1 if graphics not initialized
 */
int Platform_GetDrawableSize(int *width, int *height);

/**
 * Get the fullscreen state
 *
 * # Returns
 * - 0: Windowed
 * - 1: True fullscreen (exclusive)
 * - 2: Desktop fullscreen (borderless)
 * - -1: Graphics not initialized
 */
int Platform_GetFullscreenState(void);

/**
 * Initialize the logging system
 *
 * Creates a timestamped log file in the standard logs directory.
 * Should be called early in program startup.
 *
 * # Returns
 * - 0 on success
 * - -1 if already initialized
 * - -2 if failed to create log file
 * - -3 if failed to create log directory
 */
int32_t Platform_Log_Init(void);

/**
 * Shutdown the logging system
 *
 * Flushes buffered data and closes the log file.
 * Safe to call multiple times.
 */
void Platform_Log_Shutdown(void);

/**
 * Log a message by level number
 *
 * # Parameters
 * - `level`: Log level (0=Error, 1=Warn, 2=Info, 3=Debug, 4=Trace)
 * - `message`: Null-terminated UTF-8 message string
 *
 * # Safety
 * - `message` must be a valid null-terminated C string
 * - `message` must point to valid memory for the duration of the call
 *
 * Note: Use Platform_Log (from ffi module) for enum-based logging,
 * or this function for integer-based level specification.
 */
void Platform_LogMessage(int32_t level, const char *message);

/**
 * Log a formatted message (convenience function)
 *
 * Logs at INFO level with a module prefix.
 *
 * # Parameters
 * - `module`: Null-terminated module name (e.g., "graphics", "network")
 * - `message`: Null-terminated message string
 */
void Platform_Log_Info(const char *module, const char *message);

/**
 * Set the log level
 *
 * # Parameters
 * - `level`: 0=Error (least verbose), 1=Warn, 2=Info, 3=Debug, 4=Trace (most verbose)
 *
 * Default level is 2 (Info).
 */
void Platform_Log_SetLevel(int32_t level);

/**
 * Get the current log level
 *
 * # Returns
 * Current log level (0-4)
 */
int32_t Platform_Log_GetLevel(void);

/**
 * Flush log buffer to disk
 *
 * Call this periodically or before program exit to ensure
 * all log messages are written to the file.
 */
void Platform_Log_Flush(void);

/**
 * Initialize the network subsystem
 *
 * # Returns
 * - 0 on success
 * - -1 if already initialized
 * - -2 if enet initialization failed
 */
int32_t Platform_Network_Init(void);

/**
 * Shutdown the network subsystem
 */
void Platform_Network_Shutdown(void);

/**
 * Check if network is initialized
 *
 * # Returns
 * - 1 if initialized
 * - 0 if not initialized
 */
int32_t Platform_Network_IsInitialized(void);

/**
 * Create a new network client
 *
 * # Arguments
 * * `channel_count` - Number of channels (should match server)
 *
 * # Returns
 * * Pointer to PlatformClient on success
 * * null on failure
 */
struct PlatformClient *Platform_Client_Create(int32_t channel_count);

/**
 * Destroy a network client
 *
 * # Safety
 * * `client` must be a valid pointer from Platform_Client_Create
 */
void Platform_Client_Destroy(struct PlatformClient *client);

/**
 * Connect to a server (async)
 *
 * Starts connection process. Call Service to complete.
 *
 * # Arguments
 * * `client` - Client pointer
 * * `address` - Server address (C string, e.g., "127.0.0.1")
 * * `port` - Server port
 *
 * # Returns
 * * 0 on success (connection initiated)
 * * -1 on error
 */
int32_t Platform_Client_Connect(struct PlatformClient *client, const char *address, uint16_t port);

/**
 * Connect to a server (blocking)
 *
 * Blocks until connected or timeout.
 *
 * # Returns
 * * 0 on success
 * * -1 on error or timeout
 */
int32_t Platform_Client_ConnectBlocking(struct PlatformClient *client,
                                        const char *address,
                                        uint16_t port,
                                        uint32_t timeout_ms);

/**
 * Service the client (process events)
 *
 * # Returns
 * * 0 = No event
 * * 1 = Connected
 * * 2 = Disconnected
 * * 3 = Packet received
 * * 4 = Connection failed
 * * -1 = Error
 */
int32_t Platform_Client_Service(struct PlatformClient *client, uint32_t timeout_ms);

/**
 * Check if client is connected
 *
 * # Returns
 * * 1 if connected
 * * 0 if not connected
 */
int32_t Platform_Client_IsConnected(struct PlatformClient *client);

/**
 * Get client connection state
 *
 * # Returns
 * * 0 = Disconnected
 * * 1 = Connecting
 * * 2 = Connected
 * * 3 = Failed
 */
int32_t Platform_Client_GetState(struct PlatformClient *client);

/**
 * Send data to server
 *
 * # Arguments
 * * `client` - Client pointer
 * * `channel` - Channel to send on
 * * `data` - Packet data
 * * `size` - Data size
 * * `reliable` - 1 for reliable, 0 for unreliable
 *
 * # Returns
 * * 0 on success
 * * -1 on error
 */
int32_t Platform_Client_Send(struct PlatformClient *client,
                             uint8_t channel,
                             const uint8_t *data,
                             int32_t size,
                             int32_t reliable);

/**
 * Receive data from server
 *
 * # Arguments
 * * `client` - Client pointer
 * * `buffer` - Buffer to receive into
 * * `buffer_size` - Size of buffer
 *
 * # Returns
 * * Positive: bytes received
 * * 0: no data available
 * * -1: error
 */
int32_t Platform_Client_Receive(struct PlatformClient *client,
                                uint8_t *buffer,
                                int32_t buffer_size);

/**
 * Check if client has packets waiting
 */
int32_t Platform_Client_HasPackets(struct PlatformClient *client);

/**
 * Disconnect from server
 */
void Platform_Client_Disconnect(struct PlatformClient *client);

/**
 * Flush pending outgoing packets
 */
void Platform_Client_Flush(struct PlatformClient *client);

/**
 * Create a new network host
 *
 * # Arguments
 * * `port` - Port to bind to
 * * `max_clients` - Maximum number of clients
 * * `channel_count` - Number of channels
 *
 * # Returns
 * * Pointer to PlatformHost on success
 * * null on failure
 */
struct PlatformHost *Platform_Host_Create(uint16_t port,
                                          int32_t max_clients,
                                          int32_t channel_count);

/**
 * Destroy a network host
 *
 * # Safety
 * * `host` must be a valid pointer from Platform_Host_Create
 * * `host` must not be used after this call
 */
void Platform_Host_Destroy(struct PlatformHost *host);

/**
 * Service the host (process events)
 *
 * # Returns
 * * 0 = No event
 * * 1 = Peer connected
 * * 2 = Peer disconnected
 * * 3 = Packet received
 * * -1 = Error or null host
 */
int32_t Platform_Host_Service(struct PlatformHost *host, uint32_t timeout_ms);

/**
 * Receive a packet from the host
 *
 * # Arguments
 * * `host` - Host pointer
 * * `peer_index` - Output: peer that sent the packet
 * * `channel` - Output: channel packet was received on
 * * `buffer` - Buffer to copy packet data into
 * * `buffer_size` - Size of buffer
 *
 * # Returns
 * * Positive: number of bytes copied
 * * 0: no packet available
 * * -1: error or null pointers
 */
int32_t Platform_Host_Receive(struct PlatformHost *host,
                              uint32_t *peer_index,
                              uint8_t *channel,
                              uint8_t *buffer,
                              int32_t buffer_size);

/**
 * Check if host has packets waiting
 *
 * # Returns
 * * 1 if packets available
 * * 0 if no packets
 * * -1 on error
 */
int32_t Platform_Host_HasPackets(struct PlatformHost *host);

/**
 * Broadcast a packet to all connected peers
 *
 * # Arguments
 * * `host` - Host pointer
 * * `channel` - Channel to send on
 * * `data` - Packet data
 * * `size` - Size of data
 * * `reliable` - 1 for reliable, 0 for unreliable
 *
 * # Returns
 * * 0 on success
 * * -1 on error
 */
int32_t Platform_Host_Broadcast(struct PlatformHost *host,
                                uint8_t channel,
                                const uint8_t *data,
                                int32_t size,
                                int32_t reliable);

/**
 * Get number of connected peers
 */
int32_t Platform_Host_PeerCount(struct PlatformHost *host);

/**
 * Get the port the host is bound to
 */
uint16_t Platform_Host_GetPort(struct PlatformHost *host);

/**
 * Flush all pending outgoing packets
 */
void Platform_Host_Flush(struct PlatformHost *host);

/**
 * Create a new network manager
 *
 * Returns pointer to manager, or null on failure
 */
struct NetworkManager *Platform_NetworkManager_Create(void);

/**
 * Destroy a network manager
 *
 * # Safety
 * * `manager` must be a valid pointer from Platform_NetworkManager_Create
 */
void Platform_NetworkManager_Destroy(struct NetworkManager *manager);

/**
 * Initialize the network manager (compatibility alias)
 */
int32_t Platform_NetworkManager_Init(void);

/**
 * Shutdown the network manager (compatibility alias)
 */
void Platform_NetworkManager_Shutdown(struct NetworkManager *manager);

/**
 * Get current network mode
 *
 * Returns: 0=None, 1=Hosting, 2=Joined, -1=error
 */
int32_t Platform_NetworkManager_GetMode(struct NetworkManager *manager);

/**
 * Host a new game
 *
 * Returns 0 on success, -1 on error
 */
int32_t Platform_NetworkManager_HostGame(struct NetworkManager *manager,
                                         const char *name,
                                         uint16_t port,
                                         int32_t max_players);

/**
 * Join an existing game
 *
 * Returns 0 on success, -1 on error
 */
int32_t Platform_NetworkManager_JoinGame(struct NetworkManager *manager,
                                         const char *address,
                                         uint16_t port,
                                         uint32_t timeout_ms);

/**
 * Join a game asynchronously
 */
int32_t Platform_NetworkManager_JoinGameAsync(struct NetworkManager *manager,
                                              const char *address,
                                              uint16_t port);

/**
 * Disconnect from current session
 */
void Platform_NetworkManager_Disconnect(struct NetworkManager *manager);

/**
 * Update network - call every frame
 *
 * Returns number of packets received, or -1 on error
 */
int32_t Platform_NetworkManager_Update(struct NetworkManager *manager);

/**
 * Check if hosting
 */
int32_t Platform_NetworkManager_IsHost(struct NetworkManager *manager);

/**
 * Check if connected
 */
int32_t Platform_NetworkManager_IsConnected(struct NetworkManager *manager);

/**
 * Get peer count
 */
int32_t Platform_NetworkManager_PeerCount(struct NetworkManager *manager);

/**
 * Send data
 *
 * Returns 0 on success, -1 on error
 */
int32_t Platform_NetworkManager_SendData(struct NetworkManager *manager,
                                         uint8_t channel,
                                         const uint8_t *data,
                                         int32_t size,
                                         int32_t reliable);

/**
 * Receive data
 *
 * Returns bytes copied, 0 if no data, -1 on error
 */
int32_t Platform_NetworkManager_ReceiveData(struct NetworkManager *manager,
                                            uint32_t *peer_id,
                                            uint8_t *channel,
                                            uint8_t *buffer,
                                            int32_t buffer_size);

/**
 * Check if packets are available
 */
int32_t Platform_NetworkManager_HasPackets(struct NetworkManager *manager);

/**
 * Get local player ID
 */
int32_t Platform_NetworkManager_GetLocalPlayerId(struct NetworkManager *manager);

/**
 * Create a game packet header
 *
 * Returns 0 on success, writes header to output buffer
 */
int32_t Platform_Packet_CreateHeader(uint8_t code,
                                     uint32_t sequence,
                                     uint8_t player_id,
                                     uint8_t *out_header,
                                     int32_t *out_size);

/**
 * Get the size of a packet header
 */
int32_t Platform_Packet_HeaderSize(void);

/**
 * Validate a packet header
 *
 * Returns 1 if valid, 0 if invalid
 */
int32_t Platform_Packet_ValidateHeader(const uint8_t *data, int32_t size);

/**
 * Extract header fields from raw packet data
 *
 * Returns 0 on success, -1 on error
 */
int32_t Platform_Packet_ParseHeader(const uint8_t *data,
                                    int32_t size,
                                    uint8_t *out_code,
                                    uint32_t *out_sequence,
                                    uint8_t *out_player_id);

/**
 * Get pointer to payload data within a packet
 *
 * Returns pointer to payload start, or null on error
 * Sets out_payload_size to payload size
 */
const uint8_t *Platform_Packet_GetPayload(const uint8_t *data,
                                          int32_t size,
                                          int32_t *out_payload_size);

/**
 * Build a complete packet from header and payload
 *
 * Returns bytes written, or -1 on error
 */
int32_t Platform_Packet_Build(uint8_t code,
                              uint32_t sequence,
                              uint8_t player_id,
                              const uint8_t *payload,
                              int32_t payload_size,
                              uint8_t *out_buffer,
                              int32_t buffer_size);

/**
 * Get current FPS
 *
 * # Returns
 * Current frames per second as integer (truncated)
 */
int Platform_GetFPS(void);

/**
 * Get last frame time in milliseconds
 *
 * # Returns
 * Frame time in milliseconds (truncated to integer)
 */
int Platform_GetFrameTime(void);

/**
 * Get total frame count
 *
 * # Returns
 * Total number of frames rendered
 */
uint64_t Platform_GetFrameCount(void);

/**
 * Mark the start of a frame
 *
 * Call at the beginning of each game loop iteration.
 */
void Platform_FrameStart(void);

/**
 * Mark the end of a frame
 *
 * Call at the end of each game loop iteration.
 * This updates the FPS and frame time counters.
 */
void Platform_FrameEnd(void);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* REDALERT_PLATFORM_H */
