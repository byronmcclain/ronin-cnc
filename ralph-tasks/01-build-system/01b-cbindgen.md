# Task 01b: cbindgen Header Generation

## Dependencies
- Task 01a must be complete (Rust crate builds)
- `platform/src/lib.rs` must exist with FFI exports

## Context
We need to automatically generate C headers from our Rust code so the C++ game code can call our platform functions. cbindgen reads Rust source and generates a C header file.

## Objective
Configure cbindgen to generate `include/platform.h` with all `#[no_mangle] pub extern "C"` functions.

## Deliverables
- [ ] `platform/cbindgen.toml` - cbindgen configuration
- [ ] `platform/build.rs` - Build script for header generation
- [ ] `include/platform.h` - Generated C header (via cargo build with feature)
- [ ] Header compiles with C compiler

## Files to Create

### platform/cbindgen.toml
```toml
language = "C"

header = """
/*
 * Red Alert Platform Layer
 * Auto-generated by cbindgen - DO NOT EDIT
 *
 * This header provides the C interface to the Rust platform library.
 */
"""

trailer = """
#ifdef __cplusplus
}
#endif
"""

include_guard = "REDALERT_PLATFORM_H"
autogen_warning = "/* Warning: this file is auto-generated by cbindgen. Do not modify. */"

include_version = true
cpp_compat = true

[defines]
"target_os = macos" = "PLATFORM_MACOS"
"target_os = linux" = "PLATFORM_LINUX"

[export]
prefix = ""
include = []
exclude = []

[export.rename]

[enum]
rename_variants = "ScreamingSnakeCase"
prefix_with_name = true

[fn]
rename_args = "None"

[struct]
rename_fields = "None"

[ptr]
non_null_attribute = "_Nonnull"
```

### platform/build.rs
```rust
use std::env;
use std::path::PathBuf;

fn main() {
    // Only generate headers when explicitly requested
    if env::var("CARGO_FEATURE_CBINDGEN_RUN").is_ok() {
        generate_headers();
    }

    // Tell Cargo to re-run if these change
    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=src/ffi/mod.rs");
    println!("cargo:rerun-if-changed=cbindgen.toml");
}

fn generate_headers() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_file = PathBuf::from(&crate_dir)
        .parent()
        .unwrap()
        .join("include")
        .join("platform.h");

    // Create include directory if needed
    if let Some(parent) = output_file.parent() {
        std::fs::create_dir_all(parent).unwrap();
    }

    let config = cbindgen::Config::from_file("cbindgen.toml")
        .expect("Failed to read cbindgen.toml");

    cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_config(config)
        .generate()
        .expect("Failed to generate bindings")
        .write_to_file(&output_file);

    println!("cargo:warning=Generated: {}", output_file.display());
}
```

## Verification Command
```bash
cd platform && cargo build --features cbindgen-run && \
  test -f ../include/platform.h && \
  grep -q "Platform_Init" ../include/platform.h && \
  grep -q "Platform_Shutdown" ../include/platform.h && \
  grep -q "Platform_GetLastError" ../include/platform.h && \
  clang -fsyntax-only -x c ../include/platform.h && \
  echo "VERIFY_SUCCESS"
```

## Implementation Steps
1. Create `platform/cbindgen.toml` with C language configuration
2. Create `platform/build.rs` that runs cbindgen on feature flag
3. Create `include/` directory at repo root
4. Run `cargo build --features cbindgen-run`
5. Check that `include/platform.h` was generated
6. Verify header contains expected function declarations
7. Verify C compiler accepts the header syntax
8. If any step fails, analyze error and fix

## Expected Header Content
The generated `include/platform.h` should contain:
```c
#ifndef REDALERT_PLATFORM_H
#define REDALERT_PLATFORM_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

int32_t Platform_Init(void);
void Platform_Shutdown(void);
int32_t Platform_GetVersion(void);
int32_t Platform_GetLastError(int8_t *buffer, int32_t buffer_size);

#ifdef __cplusplus
}
#endif

#endif /* REDALERT_PLATFORM_H */
```

## Completion Promise
When verification passes (header generated and valid), output:
<promise>TASK_01B_COMPLETE</promise>

## Escape Hatch
If stuck after 15 iterations:
- Document blocking issue in `ralph-tasks/blocked/01b.md`
- Include cbindgen error output
- Output: <promise>TASK_01B_BLOCKED</promise>

## Max Iterations
15
