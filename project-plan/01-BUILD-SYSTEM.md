# Plan 01: Build System Setup (Rust + C++)

## Objective
Create a hybrid build system using CMake for the original C++ code and Cargo for the new Rust platform layer, with automatic FFI header generation via cbindgen.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                         CMake                                │
│              (orchestrates entire build)                     │
├─────────────────────────────────────────────────────────────┤
│                            │                                 │
│     ┌──────────────────────┴──────────────────────┐         │
│     ▼                                             ▼         │
│  ┌─────────────────┐                    ┌─────────────────┐ │
│  │   C++ Game      │                    │   Rust Platform │ │
│  │   (original)    │                    │   (new crate)   │ │
│  │                 │                    │                 │ │
│  │  Clang/GCC      │                    │  Cargo + rustc  │ │
│  └────────┬────────┘                    └────────┬────────┘ │
│           │                                      │          │
│           │         ┌──────────────┐             │          │
│           │         │   cbindgen   │◄────────────┘          │
│           │         │  (generates) │                        │
│           │         └──────┬───────┘                        │
│           │                │                                │
│           │                ▼                                │
│           │         ┌──────────────┐                        │
│           └────────►│  platform.h  │                        │
│                     │  (C header)  │                        │
│                     └──────────────┘                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   RedAlert.app  │
                    │   (final binary)│
                    └─────────────────┘
```

## Prerequisites

### Install Rust Toolchain
```bash
# Install rustup (Rust installer)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Add targets for universal binary
rustup target add x86_64-apple-darwin
rustup target add aarch64-apple-darwin

# Verify installation
rustc --version
cargo --version
```

### Install CMake and Tools
```bash
# Install via Homebrew
brew install cmake ninja

# Verify
cmake --version
```

## Project Structure

```
Ronin_CnC/
├── CMakeLists.txt              # Root CMake configuration
├── platform/                   # Rust platform crate
│   ├── Cargo.toml
│   ├── cbindgen.toml
│   ├── build.rs
│   └── src/
│       ├── lib.rs
│       └── ...
├── include/
│   └── platform.h              # Generated by cbindgen
├── src/
│   └── game/                   # Adapted C++ game code
├── CODE/                       # Original (reference)
├── WIN32LIB/                   # Original (reference)
└── build/                      # Build output
```

## Implementation

### 1. Root CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20)
project(RedAlert VERSION 1.0.0 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# =============================================================================
# Platform Detection
# =============================================================================

if(APPLE)
    set(PLATFORM_MACOS TRUE)
    add_compile_definitions(PLATFORM_MACOS)

    # Universal binary support
    set(CMAKE_OSX_ARCHITECTURES "x86_64;arm64" CACHE STRING "Build architectures")
    set(CMAKE_OSX_DEPLOYMENT_TARGET "10.15" CACHE STRING "Minimum macOS version")
elseif(UNIX)
    set(PLATFORM_LINUX TRUE)
    add_compile_definitions(PLATFORM_LINUX)
endif()

# =============================================================================
# Rust Integration via Corrosion
# =============================================================================

include(FetchContent)

# Fetch corrosion for CMake-Cargo integration
FetchContent_Declare(
    Corrosion
    GIT_REPOSITORY https://github.com/corrosion-rs/corrosion.git
    GIT_TAG v0.4
)
FetchContent_MakeAvailable(Corrosion)

# Import the Rust platform crate
corrosion_import_crate(MANIFEST_PATH platform/Cargo.toml)

# For universal binary on macOS
if(APPLE)
    corrosion_set_env_vars(redalert_platform
        MACOSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}
    )
endif()

# =============================================================================
# Generate C Headers from Rust (cbindgen)
# =============================================================================

set(PLATFORM_HEADER ${CMAKE_SOURCE_DIR}/include/platform.h)

add_custom_command(
    OUTPUT ${PLATFORM_HEADER}
    COMMAND cargo run --manifest-path ${CMAKE_SOURCE_DIR}/platform/Cargo.toml
            --features cbindgen-run
    DEPENDS ${CMAKE_SOURCE_DIR}/platform/src/lib.rs
            ${CMAKE_SOURCE_DIR}/platform/cbindgen.toml
    COMMENT "Generating platform.h from Rust sources"
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/platform
)

add_custom_target(generate_headers DEPENDS ${PLATFORM_HEADER})

# =============================================================================
# Game Library (Original C++ Code)
# =============================================================================

# Collect original source files
file(GLOB_RECURSE GAME_SOURCES
    "${CMAKE_SOURCE_DIR}/CODE/*.CPP"
    "${CMAKE_SOURCE_DIR}/CODE/*.C"
)

# Exclude files we're replacing
list(FILTER GAME_SOURCES EXCLUDE REGEX ".*STARTUP\\.CPP$")
list(FILTER GAME_SOURCES EXCLUDE REGEX ".*DDRAW\\.CPP$")
list(FILTER GAME_SOURCES EXCLUDE REGEX ".*SOUNDIO\\.CPP$")
# Add more exclusions as needed

add_library(game STATIC ${GAME_SOURCES})

target_include_directories(game PUBLIC
    ${CMAKE_SOURCE_DIR}/CODE
    ${CMAKE_SOURCE_DIR}/WIN32LIB/INCLUDE
    ${CMAKE_SOURCE_DIR}/include          # For platform.h
)

# Ensure headers are generated before compiling game
add_dependencies(game generate_headers)

# Link against Rust platform library
target_link_libraries(game PRIVATE redalert_platform)

# =============================================================================
# Main Executable
# =============================================================================

add_executable(RedAlert src/main.cpp)

target_link_libraries(RedAlert PRIVATE
    game
    redalert_platform
)

# macOS app bundle
if(APPLE)
    set_target_properties(RedAlert PROPERTIES
        MACOSX_BUNDLE TRUE
        MACOSX_BUNDLE_INFO_PLIST ${CMAKE_SOURCE_DIR}/platform/macos/Info.plist.in
        MACOSX_BUNDLE_BUNDLE_NAME "Red Alert"
        MACOSX_BUNDLE_GUI_IDENTIFIER "com.example.redalert"
    )
endif()

# =============================================================================
# Compile Flags
# =============================================================================

target_compile_options(game PRIVATE
    -Wall
    -Wno-unused-variable
    -Wno-unused-but-set-variable
    -Wno-missing-braces
    # Suppress warnings from old code
    -Wno-deprecated-declarations
    -Wno-writable-strings
)
```

### 2. Rust Crate: platform/Cargo.toml

```toml
[package]
name = "redalert-platform"
version = "0.1.0"
edition = "2021"
authors = ["Your Name"]
description = "Platform abstraction layer for Red Alert macOS port"

[lib]
name = "redalert_platform"
crate-type = ["staticlib"]  # Static library for linking with C++

[features]
default = []
cbindgen-run = []  # Feature to trigger header generation

[dependencies]
# Graphics and windowing
sdl2 = { version = "0.36", features = ["bundled", "static-link"] }

# Audio
rodio = { version = "0.17", default-features = false, features = ["wav", "vorbis"] }

# Networking
enet = "0.3"

# Utilities
log = "0.4"
env_logger = "0.10"
thiserror = "1.0"
libc = "0.2"
once_cell = "1.18"

# For catching panics at FFI boundary
std-panic = "0.1"

[build-dependencies]
cbindgen = "0.26"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"  # Required for FFI safety

[profile.dev]
panic = "abort"
```

### 3. cbindgen Configuration: platform/cbindgen.toml

```toml
language = "C"
header = """
/*
 * Red Alert Platform Layer
 * Auto-generated by cbindgen - DO NOT EDIT
 */
"""
include_guard = "PLATFORM_H"
autogen_warning = "/* Warning: this file is auto-generated. Do not edit. */"
include_version = true
namespace = ""
cpp_compat = true

[defines]
"target_os = macos" = "PLATFORM_MACOS"
"target_os = linux" = "PLATFORM_LINUX"

[export]
prefix = "Platform_"
include = []
exclude = []

[export.rename]
# Rename Rust types for C
"PlatformResult" = "int"

[enum]
rename_variants = "ScreamingSnakeCase"
prefix_with_name = true

[fn]
rename_args = "SnakeCase"

[struct]
rename_fields = "SnakeCase"

[ptr]
# Use explicit nullability
non_null_attribute = "_Nonnull"
```

### 4. Build Script: platform/build.rs

```rust
use std::env;
use std::path::PathBuf;

fn main() {
    // Only generate headers when explicitly requested
    if env::var("CARGO_FEATURE_CBINDGEN_RUN").is_ok() {
        generate_headers();
    }

    // Tell Cargo to re-run if these change
    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=src/ffi/mod.rs");
    println!("cargo:rerun-if-changed=cbindgen.toml");
}

fn generate_headers() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_file = PathBuf::from(&crate_dir)
        .parent()
        .unwrap()
        .join("include")
        .join("platform.h");

    // Create include directory if needed
    std::fs::create_dir_all(output_file.parent().unwrap()).unwrap();

    let config = cbindgen::Config::from_file("cbindgen.toml")
        .expect("Failed to read cbindgen.toml");

    cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_config(config)
        .generate()
        .expect("Failed to generate bindings")
        .write_to_file(&output_file);

    println!("Generated: {}", output_file.display());
}
```

### 5. Rust Library Root: platform/src/lib.rs

```rust
//! Red Alert Platform Layer
//!
//! This crate provides the platform abstraction for the Red Alert macOS port.
//! All public items are exported via C FFI for use by the C++ game code.

#![allow(clippy::missing_safety_doc)]

pub mod graphics;
pub mod audio;
pub mod input;
pub mod timer;
pub mod files;
pub mod network;
pub mod memory;

// FFI exports
pub mod ffi;

use std::sync::OnceLock;
use log::{info, error};

/// Global platform state
static PLATFORM: OnceLock<Platform> = OnceLock::new();

struct Platform {
    // Will hold SDL context, audio device, etc.
}

impl Platform {
    fn new() -> Result<Self, PlatformError> {
        Ok(Self {})
    }
}

#[derive(Debug, thiserror::Error)]
pub enum PlatformError {
    #[error("SDL error: {0}")]
    Sdl(String),

    #[error("Audio error: {0}")]
    Audio(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Already initialized")]
    AlreadyInitialized,

    #[error("Not initialized")]
    NotInitialized,
}

/// Result type for platform operations
pub type PlatformResult<T> = Result<T, PlatformError>;

// =============================================================================
// FFI Error Handling
// =============================================================================

/// Convert Result to C error code
/// 0 = success, negative = error
pub fn result_to_error_code<T>(result: PlatformResult<T>) -> i32 {
    match result {
        Ok(_) => 0,
        Err(e) => {
            error!("Platform error: {}", e);
            -1
        }
    }
}

/// Catch panics and convert to error code
pub fn catch_panic<F, T>(f: F) -> i32
where
    F: FnOnce() -> PlatformResult<T> + std::panic::UnwindSafe,
{
    match std::panic::catch_unwind(f) {
        Ok(result) => result_to_error_code(result),
        Err(_) => {
            error!("Panic caught at FFI boundary");
            -999
        }
    }
}
```

### 6. Main Entry Point: src/main.cpp

```cpp
#include <cstdio>
#include "platform.h"  // Auto-generated from Rust

// Forward declaration of game's main
extern int Game_Main(int argc, char* argv[]);

int main(int argc, char* argv[]) {
    // Initialize platform layer (calls into Rust)
    if (Platform_Init() != 0) {
        fprintf(stderr, "Failed to initialize platform\n");
        return 1;
    }

    printf("Platform initialized successfully\n");

    // Run game
    int result = Game_Main(argc, argv);

    // Cleanup
    Platform_Shutdown();

    return result;
}
```

## Build Commands

### Development Build
```bash
# Configure
cmake -B build -G Ninja

# Build
cmake --build build

# Run
./build/RedAlert.app/Contents/MacOS/RedAlert
```

### Release Build
```bash
# Configure with release
cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release

# Build
cmake --build build --config Release
```

### Generate Headers Only
```bash
cd platform
cargo build --features cbindgen-run
```

### Universal Binary (Intel + Apple Silicon)
```bash
cmake -B build -G Ninja \
    -DCMAKE_OSX_ARCHITECTURES="x86_64;arm64" \
    -DCMAKE_BUILD_TYPE=Release

cmake --build build
```

## Tasks Breakdown

### Phase 1: Rust Crate Setup (2 days)
- [ ] Create `platform/` directory structure
- [ ] Create `Cargo.toml` with dependencies
- [ ] Create `cbindgen.toml` configuration
- [ ] Create `build.rs` for header generation
- [ ] Create minimal `lib.rs` with FFI exports
- [ ] Verify `cargo build` succeeds

### Phase 2: CMake Integration (2 days)
- [ ] Create root `CMakeLists.txt`
- [ ] Integrate corrosion for Cargo builds
- [ ] Set up header generation target
- [ ] Configure game library compilation
- [ ] Test mixed C++/Rust linking

### Phase 3: FFI Foundation (2 days)
- [ ] Define error handling patterns
- [ ] Create panic-catching wrappers
- [ ] Generate initial `platform.h`
- [ ] Test calling Rust from C++

### Phase 4: Validation (1 day)
- [ ] Build complete project
- [ ] Verify universal binary works
- [ ] Test on Intel and Apple Silicon Macs
- [ ] Document build process

## Files to Create

| File | Purpose |
|------|---------|
| `CMakeLists.txt` | Root build configuration |
| `platform/Cargo.toml` | Rust crate configuration |
| `platform/cbindgen.toml` | Header generation config |
| `platform/build.rs` | Build script |
| `platform/src/lib.rs` | Crate root |
| `platform/src/ffi/mod.rs` | FFI exports |
| `src/main.cpp` | Entry point |
| `include/.gitkeep` | Placeholder for generated headers |

## Acceptance Criteria

- [ ] `cargo build` succeeds in `platform/`
- [ ] `cmake --build build` succeeds
- [ ] `platform.h` is auto-generated
- [ ] Rust functions callable from C++
- [ ] Universal binary builds on macOS
- [ ] No manual header maintenance needed

## Estimated Duration
**5-7 days**

## Dependencies
- Rust toolchain (rustup)
- CMake 3.20+
- Ninja (recommended)
- Xcode Command Line Tools

## Next Plan
Once build system works, proceed to **Plan 02: Platform Abstraction Layer**
